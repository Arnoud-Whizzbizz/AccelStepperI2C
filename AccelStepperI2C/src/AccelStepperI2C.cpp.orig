/*!
  @file AccelStepperI2C.cpp
  @brief Part of the AccelStepperI2C firmware/library
  @section author Author
  Copyright (c) 2022 juh
  @section license License
  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation, version 2.
*/

#include <Wire.h>
#include <AccelStepperI2C.h>

/*
 *
 * Helper functions and methods start here
 *
 */

// Tell slave to reset.
// Not a method, it needs to work even before any steppers have been constructed.
void resetAccelStepperSlave(uint8_t address) {
    SimpleBuffer b;
    b.init(4);
    b.write(resetCmd);
    b.setCRC8();
    Wire.beginTransmission(address);
    Wire.write(b.buffer, b.idx);
    Wire.endTransmission();
}

// reset stepper's buffer and write header bytes...
void AccelStepperI2C::prepareCommand(uint8_t cmd) {
    buf.reset();
    buf.write(cmd);     // [1]: command
    buf.write(myNum);   // [2]: number of stepper to address
}

// ... compute checksum and send it.
// returns true if sending was successful. Also sets sentOK for client to check
bool AccelStepperI2C::sendCommand() {
    buf.setCRC8();  // [0]: CRC8
    Wire.beginTransmission(address);
    Wire.write(buf.buffer, buf.idx);
    sentOK = (Wire.endTransmission() == 0);  // for client to check if command was transmitted successfully
    return sentOK; // internal: true on success;
}

// read slave's reply
// returns true if received data was correct regarding expected lenght and checksum
bool AccelStepperI2C::readResult(uint8_t numBytes) {
    buf.reset();
    if (Wire.requestFrom(address, numBytes) > 0) { // success
        while (buf.idx <= numBytes and buf.idx < buf.maxLen) {
            buf.write(Wire.read());
            //buf.buffer[buf.idx++] = Wire.read();
        }
        resultOK = buf.checkCRC8();
    } else { // some transmission error
        resultOK = false;
    }
    buf.reset(); // reset for reading
    return resultOK;
}
// delay(I2CrequestDelay); // give slave time to answer ### needs tuning or better make it configurable, as it will depend on ÂµC and bus frequency etc.
// Serial.print("Requested bytes: "); Serial.print(numBytes); Serial.print(" | Received bytes: "); Serial.print(receivedBytes); Serial.print(":  ");
//Serial.print(buf.buffer[buf.idx-1], HEX); Serial.print(" ");
//Serial.print("  ("); Serial.print(buf.idx); Serial.println(" bytes actual)");
//  resultOK = (numBytes == buf.idx); // useless, doesn't work as expected due to errors in Arduino documentation of requestFrom()


/*
 *
 * AccelStepper wrapper functions start here
 *
 */

// Constructor
AccelStepperI2C::AccelStepperI2C(uint8_t i2c_address,
                                 uint8_t interface,
                                 uint8_t pin1, uint8_t pin2, uint8_t pin3, uint8_t pin4,
                                 bool enable) {
    address = i2c_address;
    buf.init(maxBuf);
    prepareCommand(addStepperCmd); // Will send -1 as stepper num, since myNum is not set yet, but that's ok, as addStepperCmd doesn't need it.
    buf.write(interface); // parameters
    buf.write(pin1);
    buf.write(pin2);
    buf.write(pin3);
    buf.write(pin4);
    buf.write(enable);
    if (sendCommand() and readResult(1)) {
        buf.read(myNum);
    } // else leave myNum at -1 (= failed)
}

void AccelStepperI2C::moveTo(long absolute) {
    prepareCommand(moveToCmd);
    buf.write(absolute);
    sendCommand();
}

void AccelStepperI2C::move(long relative) {
    prepareCommand(moveCmd);
    buf.write(relative);
    sendCommand();
}

// don't use, use state machine instead
// will always return true, as result polling over I2C makes not a lot of sense here
boolean AccelStepperI2C::run() {
    prepareCommand(runCmd);
    if (sendCommand() and readResult(1)) {
        boolean res;
        buf.read(res);
        return res;
    } else {
        return true; // "still moving"
    }
}

// don't use, use state machine instead
// will always return true, as result polling over I2C makes not a lot of sense here
boolean AccelStepperI2C::runSpeed() {
    prepareCommand(runSpeedCmd);
    sendCommand();
    return true; // "motor was stepped"
}

// don't use, use state machine instead
// will always return true, as result polling over I2C makes not a lot of sense here
bool AccelStepperI2C::runSpeedToPosition() {
    prepareCommand(runSpeedToPositionCmd);
    sendCommand();
    return true; // "motor was stepped"
}


long AccelStepperI2C::distanceToGo() {
    prepareCommand(distanceToGoCmd);
    if (sendCommand() and readResult(4)) {
        long res;
        buf.read(res);
        return res;
    } else {
        return resError;
    }
}

long AccelStepperI2C::targetPosition() {
    prepareCommand(targetPositionCmd);
    if (sendCommand() and readResult(4)) {
        long res;
        buf.read(res);
        return res;
    } else {
        return resError;
    }
}

long AccelStepperI2C::currentPosition() {
    prepareCommand(currentPositionCmd);
    if (sendCommand() and readResult(4)) {
        long res;
        buf.read(res);
        return res;
    } else {
        return resError;
    }
}

void AccelStepperI2C::setCurrentPosition(long position) {
    prepareCommand(setCurrentPositionCmd);
    buf.write(position);
    sendCommand();
}

void AccelStepperI2C::setMaxSpeed(float speed) {
    prepareCommand(setMaxSpeedCmd);
    buf.write(speed);
    sendCommand();
}

float AccelStepperI2C::maxSpeed() {
    prepareCommand(maxSpeedCmd);
    if (sendCommand() and readResult(4)) {
        float res;
        buf.read(res);
        return res;
    } else {
        return resError;
    }
}

void AccelStepperI2C::setAcceleration(float acceleration) {
    prepareCommand(setAccelerationCmd);
    buf.write(acceleration);
    sendCommand();
}

void AccelStepperI2C::setSpeed(float speed) {
    prepareCommand(setSpeedCmd);
    buf.write(speed);
    sendCommand();
}

float AccelStepperI2C::speed() {
    prepareCommand(speedCmd);
    if (sendCommand() and readResult(4)) {
        float res;
        buf.read(res);
        return res;
    } else {
        return resError;
    }
}

void    AccelStepperI2C::disableOutputs() {
    prepareCommand(disableOutputsCmd);
    sendCommand();
}

void    AccelStepperI2C::enableOutputs() {
    prepareCommand(enableOutputsCmd);
    sendCommand();
}

void AccelStepperI2C::setMinPulseWidth(unsigned int minWidth) {
    prepareCommand(setMinPulseWidthCmd);
    buf.write(minWidth);
    sendCommand();
}

void AccelStepperI2C::setEnablePin(uint8_t enablePin) {
    prepareCommand(setEnablePinCmd);
    buf.write(enablePin);
    sendCommand();
}

void AccelStepperI2C::setPinsInverted(bool directionInvert, bool stepInvert, bool enableInvert) {
    prepareCommand(setPinsInverted1Cmd);
    uint8_t bits = (uint8_t)directionInvert << 0 | (uint8_t)stepInvert << 1 | (uint8_t)enableInvert << 2;
    buf.write(bits);
    sendCommand();
}

void AccelStepperI2C::setPinsInverted(bool pin1Invert, bool pin2Invert, bool pin3Invert, bool pin4Invert, bool enableInvert) {
    prepareCommand(setPinsInverted2Cmd);
    uint8_t bits = (uint8_t)pin1Invert << 0 | (uint8_t)pin2Invert << 1 | (uint8_t)pin3Invert << 2 | (uint8_t)pin4Invert << 3 | (uint8_t)enableInvert << 4;
    buf.write(bits);
    sendCommand();
}

// blocking, not implemented (yet?)
void AccelStepperI2C::runToPosition() {
}

// blocking, not implemented (yet?)
void AccelStepperI2C::runToNewPosition(long position) {
    position++; // just to stop the compiler from complaining
}

void AccelStepperI2C::stop() {
    prepareCommand(stopCmd);
    sendCommand();
}

bool AccelStepperI2C::isRunning() {
    prepareCommand(isRunningCmd);
    if (sendCommand() and readResult(1)) {
        bool res;
        buf.read(res);
        return res;
    } else {
        return false;
    }
}

/*
 *
 * Methods specific to AccelStepperI2C start here
 *
 */

void AccelStepperI2C::setState(uint8_t newState) {
    prepareCommand(setStateCmd);
    buf.write(newState);
    sendCommand();
}

void AccelStepperI2C::stopState() {
    setState(state_stopped);
}

void AccelStepperI2C::runState() {
    setState(state_run);
}

void AccelStepperI2C::runSpeedState() {
    setState(state_runSpeed);
}

void AccelStepperI2C::runSpeedToPositionState() {
    setState(state_runSpeedToPosition);
}

void AccelStepperI2C::setEndstopPin(int8_t pin,
                                    bool activeLow,
                                    bool internalPullup) {
    prepareCommand(setEndstopPinCmd);
    buf.write(pin);
    buf.write(activeLow);
    buf.write(internalPullup);
    sendCommand();
}


void AccelStepperI2C::enableEndstops(bool enable) {
    prepareCommand(enableEndstopsCmd);
    buf.write(enable);
    sendCommand();
}

uint8_t AccelStepperI2C::endstops() { // returns endstop(s) states in bits 0 and 1
    prepareCommand(endstopsCmd);
    if (sendCommand() and readResult(1)) {
        uint8_t res = 0;
        buf.read(res);
        return res;
    } else {
        return 0;
    }
}











