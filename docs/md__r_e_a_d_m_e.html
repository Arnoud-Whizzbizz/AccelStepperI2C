<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AccelStepperI2C: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AccelStepperI2C
   &#160;<span id="projectnumber">v 0.1</span>
   </div>
   <div id="projectbrief">I2C wrapper (and a bit more) for the AccelStepper Arduino library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md0">Introduction</a></li>
<li class="level1"><a href="#autotoc_md1">How does it work?</a></li>
<li class="level1"><a href="#autotoc_md2">Differences from AccelStepper</a></li>
<li class="level1"><a href="#autotoc_md3">Additional features</a></li>
<li class="level1"><a href="#autotoc_md4">Restrictions</a></li>
<li class="level1"><a href="#Error-handling">Error handling</a></li>
<li class="level1"><a href="#autotoc_md5">Usage</a></li>
<li class="level1"><a href="#autotoc_md6">Performance and diagnostics</a></li>
<li class="level1"><a href="#autotoc_md7">Example</a></li>
<li class="level1"><a href="#autotoc_md8">Documentation</a></li>
<li class="level1"><a href="#autotoc_md9">Author</a></li>
<li class="level1"><a href="#autotoc_md10">Copyright</a></li>
<li class="level1"><a href="#autotoc_md11">License</a></li>
<li class="level1"><a href="#autotoc_md12">History</a></li>
</ul>
</div>
<div class="textblock"><p>Warning: Pre-alpha! Not for production, only for feedback. Expect things to break, until stated otherwise.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Introduction</h1>
<p>This is an I2C wrapper for Mike McCauley's <a href="https://www.airspayce.com/mikem/arduino/AccelStepper/index.html">AccelStepper library</a> with additional support for two end stops per stepper. It consists of the <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> Arduino-based <b>firmware</b> for one or more I2C-slaves, and a corresponding Arduino <b>library</b> for the I2C-master. Think of it as a more accessible and more flexible replacement for dedicated I2C stepper motor controller ICs like AMIS-30622, PCA9629 or TMC223.</p>
<p>The firmware has been tested on ATmega328 Arduinos (Uno, Nano etc.) and ESP32s, it might work on other Arduino supported platforms.</p>
<p><a href="https://github.com/ftjuh/AccelStepperI2C">Download AccelStepperI2C on github.</a></p>
<p><a href="https://ftjuh.github.io/AccelStepperI2C/">AccelStepperI2C library documentation</a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
How does it work?</h1>
<ul>
<li>One or more Arduino-likes, acting as <b>I2C-slaves</b>, run up to eight stepper motors each. The slaves run the <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> firmware (<a class="el" href="firmware_8ino.html" title="Firmware for an I2C slave controlling up to 8 stepper motors via AccelStepper library.">firmware.ino</a>), which exposes the AccelStepper functionality via I2C. Steppers are driven by any method supported by AccelStepper except AccelStepper::FUNCTION, e.g. AccelStepper::DRIVER with StepStick compatible A4988, DRV8825 or TMC2100 stepper drivers. An obvious example is the Arduino UNO with a Protoneer CNC shield (recent <a href="https://www.elecrow.com/arduino-cnc-shield-v3-51-grbl-v0-9-compatible-uses-pololu-drivers.html">V3.51</a> or <a href="https://forum.protoneer.co.nz/viewforum.php?f=17">V3.00 clone</a>).</li>
<li>Another device, acting as <b>I2C-master</b>, controls the slave(s) via I2C with the help of the <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> library. <a href="https://ftjuh.github.io/AccelStepperI2C/">Its interface</a> is largely identical to the original AccelStepper library.</li>
<li>Refer to the <a href="https://github.com/ftjuh/AccelStepperI2C/tree/master/AccelStepperI2C/examples">examples</a> to see how it works in detail.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Differences from AccelStepper</h1>
<ul>
<li>With the exception of two blocking functions (see below), AccelStepper needs the client to <b>constantly 'poll'</b> each stepper by invoking one of the run() commands (run(), runSpeed(), or runSpeedToPosition()) at a frequency which mustn't be lower than the stepping frequency. Over I2C, this would clutter the bus, put limits on stepper speeds, and be unstable if there are other I2C devices on the bus, particularly with multiple steppers and microstepping.</li>
<li>To solve this problem, the <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> firmware implements a <b>state machine</b> for each connected stepper which makes the slave do the polling locally on its own.</li>
<li>All the master has to do is making the appropriate settings, e.g. setting a target with <a class="el" href="class_accel_stepper_i2_c.html#a06ee86271f675746386c4cb86b6c6182">AccelStepperI2C::moveTo()</a> or <a class="el" href="class_accel_stepper_i2_c.html#af9c59ca7c83e9e2452cdc6b3a3b50ed9">AccelStepperI2C::move()</a>, or choosing a speed with <a class="el" href="class_accel_stepper_i2_c.html#a2a8c92150ae055c7ff696ff98ddb7a38">AccelStepperI2C::setSpeed()</a> and then start the slave's state machine with one of<ul>
<li><a class="el" href="class_accel_stepper_i2_c.html#a934c71dc0f3b534bc859f40e785066b6" title="Will poll run(), i.e. run to the target with acceleration and stop the state machine upon reaching it...">AccelStepperI2C::runState()</a>: will poll run(), i.e. run to the target with acceleration, and stop the state machine upon reaching it</li>
<li><a class="el" href="class_accel_stepper_i2_c.html#a60f56e376242af7fe69fda51c6758ec7" title="Will poll runSpeed(), i.e. run at constant speed until told otherwise (see AccelStepperI2C::stopState...">AccelStepperI2C::runSpeedState()</a>: will poll runSpeed(), i.e. run at constant speed until told otherwise (see <a class="el" href="class_accel_stepper_i2_c.html#a509c7691efe52e80615e937e693bdbc1" title="Will stop any of the above states, i.e. stop polling. It does nothing else, so the master is solely i...">AccelStepperI2C::stopState()</a>), or</li>
<li><a class="el" href="class_accel_stepper_i2_c.html#a935522089c48b23c0e9f17b242d7d94f" title="Will poll runSpeedToPosition(), i.e. run at constant speed until target has been reached.">AccelStepperI2C::runSpeedToPositionState()</a>: will poll runSpeedToPosition(), i.e. run at constant speed until target has been reached.</li>
</ul>
</li>
<li><a class="el" href="class_accel_stepper_i2_c.html#a509c7691efe52e80615e937e693bdbc1" title="Will stop any of the above states, i.e. stop polling. It does nothing else, so the master is solely i...">AccelStepperI2C::stopState()</a> will stop any of the above states, i.e. stop polling. It does nothing else, so the master is solely in command of target, speed, and other settings.</li>
</ul>
<h1><a class="anchor" id="autotoc_md3"></a>
Additional features</h1>
<ul>
<li>Up to two <b>end stop switches</b> can be defined for each stepper. If enabled and the stepper runs into one of them, it will make the state machine stop just like <a class="el" href="class_accel_stepper_i2_c.html#a509c7691efe52e80615e937e693bdbc1" title="Will stop any of the above states, i.e. stop polling. It does nothing else, so the master is solely i...">AccelStepperI2C::stopState()</a>. Of course, this is most useful in combination with <a class="el" href="class_accel_stepper_i2_c.html#a60f56e376242af7fe69fda51c6758ec7" title="Will poll runSpeed(), i.e. run at constant speed until told otherwise (see AccelStepperI2C::stopState...">AccelStepperI2C::runSpeedState()</a> for homing and calibration tasks at startup.</li>
<li>This is a list of functions introduced by the <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> library:<ul>
<li>void <a class="el" href="_accel_stepper_i2_c_8h.html#a1a5368a04a51848489ce42d0329eb62a" title="Tells the slave to reset. Call this before adding any steppers if master and slave resets are not syn...">resetAccelStepperSlave(uint8_t address)</a></li>
<li>void <a class="el" href="_accel_stepper_i2_c_8h.html#aaf3220824c0b20160b8fbdb581dd23b4" title="Permanently change the I2C address of the device. New address is stored in EEPROM and will be active ...">changeI2Caddress(uint8_t address, uint8_t newAddress)</a></li>
<li>uint16_t setI2Cdelay (uint16_t delay)</li>
<li>void <a class="el" href="_accel_stepper_i2_c_8h.html#a3aeca848bcd87c850b8d31640c08c19d" title="Define global interrupt pin which can be enabled for each stepper seperately to inform the master tha...">setInterruptPin(uint8_t address, int8_t pin, bool activeHigh)</a></li>
<li>uint16_t <a class="el" href="_accel_stepper_i2_c_8h.html#a2c158fe6e7f01a83b4c954ac7f443337" title="Get version of slave firmware.">getVersion(uint8_t address)</a></li>
<li>bool <a class="el" href="_accel_stepper_i2_c_8h.html#a740e271c085f389261e5ff455ca348c4" title="Get version of slave firmware and compare it with library version.">checkVersion(uint8_t address)</a>;</li>
</ul>
</li>
<li>This is a full list of methods introduced by the <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> class:<ul>
<li>void <a class="el" href="class_accel_stepper_i2_c.html#a0015e762b6a5ab8a545574e1642358ef" title="Start or stop sending interrupts to master for this stepper. An interrupt will be sent whenever a sta...">AccelStepperI2C::enableInterrupts(bool enable)</a></li>
<li>void <a class="el" href="class_accel_stepper_i2_c.html#a0cc31b57b4d082744a94cb712b71a6e5" title="Define a new endstop pin. Each stepper can have up to two, so don&#39;t call this more than twice per ste...">AccelStepperI2C::setEndstopPin(int8_t pin, bool activeLow, bool internalPullup)</a></li>
<li>void <a class="el" href="class_accel_stepper_i2_c.html#ab0392ba30b4854704bd08b588db17401" title="Tell the state machine to check the endstops regularly. If two switches are used, it does not differe...">AccelStepperI2C::enableEndstops(bool enable)</a></li>
<li>uint8_t <a class="el" href="class_accel_stepper_i2_c.html#af27f8157184e75d824faa9634113c67c" title="Read current state of endstops.">AccelStepperI2C::endstops()</a></li>
<li>void AccelStepperI2C::enableDiagnostics(bool enable)</li>
<li>void AccelStepperI2C::diagnostics(diagnosticsReport* report)</li>
<li>void <a class="el" href="class_accel_stepper_i2_c.html#a213e402f63727c105d9ea2a20b125fe8" title="Set the state machine&#39;s state manually.">AccelStepperI2C::setState(uint8_t newState)</a></li>
<li>uint8_t <a class="el" href="class_accel_stepper_i2_c.html#aea0a376b22b0a0065b2257ec74f7e3b3" title="Read the state machine&#39;s state (it may have been changed by endstop or target reached condition).">AccelStepperI2C::getState()</a></li>
<li>void <a class="el" href="class_accel_stepper_i2_c.html#a509c7691efe52e80615e937e693bdbc1" title="Will stop any of the above states, i.e. stop polling. It does nothing else, so the master is solely i...">AccelStepperI2C::stopState()</a></li>
<li>void <a class="el" href="class_accel_stepper_i2_c.html#a934c71dc0f3b534bc859f40e785066b6" title="Will poll run(), i.e. run to the target with acceleration and stop the state machine upon reaching it...">AccelStepperI2C::runState()</a></li>
<li>void <a class="el" href="class_accel_stepper_i2_c.html#a60f56e376242af7fe69fda51c6758ec7" title="Will poll runSpeed(), i.e. run at constant speed until told otherwise (see AccelStepperI2C::stopState...">AccelStepperI2C::runSpeedState()</a></li>
<li>void <a class="el" href="class_accel_stepper_i2_c.html#a935522089c48b23c0e9f17b242d7d94f" title="Will poll runSpeedToPosition(), i.e. run at constant speed until target has been reached.">AccelStepperI2C::runSpeedToPositionState()</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
Restrictions</h1>
<ul>
<li>The original run(), runSpeed(), or runSpeedToPosition() are implemented, but I discourage using them directly. Particularly in high load situations with multiple steppers, microstepping, and other time-critical I2C traffic, it's silly to trigger each stepper step over I2C. Use the state machine instead. If you feel you must use them, take it slowly and consider <a href="https://www.arduino.cc/en/Reference/WireSetClock">increasing the I2C bus frequency</a>.</li>
<li>Each library function call, its parameters, and return value has to be transmitted back and forth via I2C. This makes things slower, less precise, and prone to errors. To be safe from errors, you'll need to do some extra checking (see <a href="#Error-handling">Error handling</a>).</li>
<li>The two blocking functions, runToPosition() and runToNewPosition(), are not implemented at the moment. I never saw their purpose, anyway, as their behavior can easily implemented with the existing functionality. Also, naturally, you cannot declare your own stepping functions with the <a href="https://www.airspayce.com/mikem/arduino/AccelStepper/classAccelStepper.html#afa3061ce813303a8f2fa206ee8d012bd">constructor [2/2] variant</a>.</li>
<li>No serialization protocol is used at the moment, so the implementation is machine dependent in regard to the endians and sizes of data types. Arduinos Uno/Nano and ESP8266 have been tested and work well together, as should any other Arduino supporting platform.</li>
<li><strike>There is no interrupt mechanism at the moment which tells the master that a state machine job has finished or an endstop has been triggered. So the master still needs to poll the slave with one of <a class="el" href="class_accel_stepper_i2_c.html#a26e27bf5d72113dc43694c87ed4a75f4">AccelStepperI2C::distanceToGo()</a>, <a class="el" href="class_accel_stepper_i2_c.html#ac3a25dd2091e8b7a2aaa415150957b7e">AccelStepperI2C::currentPosition</a>, <a class="el" href="class_accel_stepper_i2_c.html#a5d61e5c0ac971764de463e1d958a517d">AccelStepperI2C::isRunning()</a>, or <a class="el" href="class_accel_stepper_i2_c.html#af27f8157184e75d824faa9634113c67c" title="Read current state of endstops.">AccelStepperI2C::endstops()</a> but can do so at a much more reasonable frequency.</strike></li>
<li><strike>Currently, there is no error checking of the master-slave communication, which uses a very basic (i.e. non existing) protocol. The master will have to deal with any transmission errors should they occur.</strike></li>
</ul>
<p>Have a look at the <a href="https://ftjuh.github.io/AccelStepperI2C/todo.html">todo list</a> to see what improvements are still planned.</p>
<h1><a class="anchor" id="Error-handling"></a>
Error handling</h1>
<p>If I2C transmission problems occur, any call to the library could fail and, possibly worse, every return value could be corrupted. Uncontrolled or unexpected stepper movements could lead to serious problems. That's why each command and response is sent with a CRC8 checksum. To find out if a master's command or a slave's response was <b>transmitted correctly</b>, the master can do the following checks:</p>
<ul>
<li>If <a class="el" href="class_accel_stepper_i2_c.html#a2c4d58dc9b219725a3d40c8756e5302e" title="True if previous function call was successfully transferred to slave.">AccelStepperI2C::sentOK</a> is false, the function call was not properly transmitted.</li>
<li>If <a class="el" href="class_accel_stepper_i2_c.html#a0c74bcb33dca28cd2e23a54a7da395ea" title="True if return value from previous function call was received successfully.">AccelStepperI2C::resultOK</a> is false, the data returned from a function call is invalid.</li>
</ul>
<p>The slave keeps an internal count of the number of failed transmissions, i.e. the number of cases that sentOK and resultOK came back false. If the master doesn't want to check each transmission separately, it can use one of the following methods at the end of a sequence of transmissions (e.g. setup and configuration of the slave) or at the end of some program loop:</p>
<ul>
<li>uint16_t <a class="el" href="class_accel_stepper_i2_c.html#a45250f325c2d95647fb11c6cb3f1bafa" title="Return and reset the number of failed commands sent since the last time this method was used....">AccelStepperI2C::sentErrors()</a> - number of false sentOK events</li>
<li>uint16_t <a class="el" href="class_accel_stepper_i2_c.html#a5b2c647f86b8bbe15dd57cd4494b2bb0" title="Return and reset the number of failed receive events since the last time this method was used....">AccelStepperI2C::resultErrors()</a> - number of false resultOK events</li>
<li>uint16_t <a class="el" href="class_accel_stepper_i2_c.html#acd0593433947161edb9ef502b751662b" title="Return and reset the sum of failed commands sent and failed receive events since the last time this m...">AccelStepperI2C::transmissionErrors()</a> - sum of the above</li>
</ul>
<p>The respective counter(s) will be reset with each invocation of these methods.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Usage</h1>
<ol type="1">
<li>Install the libraries <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a>, <a class="el" href="class_simple_buffer.html">SimpleBuffer</a>, and of course the original AccelStepper to the Arduino environment.</li>
<li>Upload <a class="el" href="firmware_8ino.html" title="Firmware for an I2C slave controlling up to 8 stepper motors via AccelStepper library.">firmware.ino</a> to one Arduino (slave). Connect steppers and stepper drivers or use a dedicated hardware, e.g. Arduino UNO with CNC V3.00 shield.</li>
<li>Upload example sketch or your own sketch which uses the <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> library to another Arduino-like (master).</li>
<li>Connect the I2C bus of both devices (usually A4&lt;-&gt;A4, A5&lt;-&gt;A5, GND&lt;-&gt;GND). Don't fortget two I2C pullups and, if needed, level-shifters. Also connect +5V&lt;-&gt;+5V to power one board from the other, if needed.</li>
<li>Now (not earlier) provide external power to the steppers and power to the Arduinos.</li>
</ol>
<p>Have a look at the examples for usage of the library.</p>
<p>Important:</p>
<ul>
<li>The <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> constructor needs the Wire library to be already initialized. So don't invoke the constructor when declaring an object, use <b>new</b> during <a class="el" href="firmware_8ino.html#a4fc01d736fe50cf5b977f755b675f11d" title="setup system">setup()</a>.</li>
<li>Take care of <a href="#Error-handling">error handling</a> if your steppers gone wild might damage something.</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
Performance and diagnostics</h1>
<p>On a normal ATmega328 @ 16MHz, the original AccelStepper can run <a href="https://www.airspayce.com/mikem/arduino/AccelStepper/classAccelStepper.html#details">about 4000 steps per second</a> at max. The <a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> state machine only takes a tiny bite away from that. However, if you are using a lot of steppers, need high speeds, and/or if you are using a big microstepping factor, a normal Arduino can quickly become too slow. So choose your platform wisely, the ESP32 will be 10-20 times faster.</p>
<p>If the slave firmware was compiled with the <a class="el" href="firmware_8ino.html#ae19f7f44c494f571f8860c91f2fdba22">DIAGNOSTICS_AccelStepperI2C</a> compiler directive, you can use the <a class="el" href="_accel_stepper_i2_c_8cpp.html#a87520fe47b6444ff58585f1cca1ebd06" title="Get most recent diagnostics data. Needs diagnostics enabled and a slave which was compiled with the D...">diagnostics()</a> function to investigate the system performance. It will use a struct of type <a class="el" href="structdiagnostics_report.html">diagnosticsReport</a> with information on</p>
<ul>
<li>the number of main loop executions since the last reboot,</li>
<li>the time needed to process (interpret) the most recently received command,</li>
<li>the time the slave spent in the most recent onRequest() interrupt, and</li>
<li>the time the slave spent in the most recent onReceive() interrupt.</li>
</ul>
<h1><a class="anchor" id="autotoc_md7"></a>
Example</h1>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Example code for I2C master which controls an I2C-slave with firmware.ino</div>
<div class="line">// Slave hardware setup (just like CNC shield V3.00): A4988 or similar </div>
<div class="line">// with STEP on pin 2, DIR on pin 5 and ENABLE on pin 8 with pullup; Endstop </div>
<div class="line">// to ground on pin 9 </div>
<div class="line">// I2C connection: A4&lt;-&gt;A4, A5&lt;-&gt;A5, GND&lt;-&gt;GND</div>
<div class="line">// Optional: 5V&lt;-&gt;5V, Reset&lt;-&gt;Reset (see below)</div>
<div class="line"> </div>
<div class="line">#include &lt;Arduino.h&gt;</div>
<div class="line">#include &lt;AccelStepperI2C.h&gt;</div>
<div class="line">#include &lt;Wire.h&gt;</div>
<div class="line"> </div>
<div class="line">const uint8_t addr = 0x8; // i2c address of slave</div>
<div class="line">const uint8_t stepXpin = 2; // A4988 STEP pin</div>
<div class="line">const uint8_t dirXpin = 5; // A4988 DIR pin</div>
<div class="line">const uint8_t enableXpin = 8; // A4988 _ENABLE_ pin</div>
<div class="line">const uint8_t endstopXpin = 9; // endswitch to ground</div>
<div class="line"> </div>
<div class="line">// do not invoke constructor here, we need to establish I2C connection first.</div>
<div class="line">AccelStepperI2C* X; </div>
<div class="line"> </div>
<div class="line">void setup() {</div>
<div class="line"> </div>
<div class="line">  Serial.begin(115200);</div>
<div class="line">  // Important: initialize Wire before creating AccelStepperI2C objects</div>
<div class="line">  Wire.begin();</div>
<div class="line">  // reset slave (only needed if not reset with master by hardware connection)</div>
<div class="line">  resetAccelStepperSlave(addr);</div>
<div class="line">  delay(1887); // give slave time to reboot</div>
<div class="line"> </div>
<div class="line">  X = new AccelStepperI2C(addr, AccelStepper::DRIVER, stepXpin, dirXpin);</div>
<div class="line">  if (X-&gt;myNum &lt; 0) { // allocating stepper failed</div>
<div class="line">    Serial.print(&quot;Error: Could not add stepper. Halting\n\n&quot;);</div>
<div class="line">    while (true) {}</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // We&#39;re trusting the system to transmit reliably. If you&#39;re more paranoid</div>
<div class="line">  // you could check X.sentOK after each function call.</div>
<div class="line">  X-&gt;setEnablePin(8);</div>
<div class="line">  X-&gt;setPinsInverted(false, false, true); // directionInvert, stepInvert, enableInvert</div>
<div class="line">  X-&gt;enableOutputs();</div>
<div class="line">  X-&gt;setMaxSpeed(2000);</div>
<div class="line">  X-&gt;setAcceleration(200);</div>
<div class="line">  // install endstop switch; activeLow works nicely together with internal pullup</div>
<div class="line">  X-&gt;setEndstopPin(endstopXpin, true, true); // pin, activeLow, internalPullup</div>
<div class="line">  X-&gt;enableEndstops();</div>
<div class="line">  X-&gt;moveTo(5000);</div>
<div class="line">  X-&gt;runState();</div>
<div class="line">  </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void loop() {</div>
<div class="line">  </div>
<div class="line">  if (!X-&gt;isRunning()) {</div>
<div class="line">    X-&gt;moveTo(- X-&gt;currentPosition()); </div>
<div class="line">    // On reaching the target, the state machine stopped. So let&#39;s start it again.</div>
<div class="line">    X-&gt;runState(); </div>
<div class="line">  }</div>
<div class="line">  delay(100); // let&#39;s limit target polling to some sensible frequency</div>
<div class="line">  </div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
Documentation</h1>
<p><a href="https://ftjuh.github.io/AccelStepperI2C/">Find the AccelStepperI2C library documentation here</a>. It only deals with differences from running the AccelStepper library locally. If not stated otherwise, expect <a class="el" href="class_accel_stepper_i2_c.html">functions and parameters</a> to work as in the original, keeping the above differences and restrictions in mind.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Author</h1>
<p>This is my first "serious" piece of software published on github. Although I've some background in programming, mostly in the Wirth-tradition languages, I'm far from being a competent or even avid c++ programmer. At the same time I have a tendency to over-engineer (not a good combination), so be warned and use this at your own risk. My current main interest is in 3D printing, you can find me on <a href="https://www.prusaprinters.org/social/202816-juh/about">prusaprinters</a>, <a href="https://www.thingiverse.com/juh/designs">thingiverse</a>, and <a href="https://www.youmagine.com/juh3d/designs">youmagine</a>. This library was developed as part of my <a href="https://www.prusaprinters.org/prints/115049-stepfish-fischertechnik-i2c-stepper-motor-controll">StepFish project</a> (<a href="https://forum.ftcommunity.de/viewtopic.php?t=5341">also here</a>).</p>
<p>Contact me at <a href="#" onclick="location.href='mai'+'lto:'+'juh'+'@p'+'ost'+'eo'+'.or'+'g'; return false;">juh@p<span style="display: none;">.nosp@m.</span>oste<span style="display: none;">.nosp@m.</span>o.org</a>.</p>
<p>Jan (juh)</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Copyright</h1>
<p>This software is Copyright (C) 2022 juh (<a href="#" onclick="location.href='mai'+'lto:'+'juh'+'@p'+'ost'+'eo'+'.or'+'g'; return false;">juh@p<span style="display: none;">.nosp@m.</span>oste<span style="display: none;">.nosp@m.</span>o.org</a>)</p>
<h1><a class="anchor" id="autotoc_md11"></a>
License</h1>
<p><a class="el" href="class_accel_stepper_i2_c.html" title="An I2C wrapper class for the AccelStepper library.">AccelStepperI2C</a> is distributed under the GNU GENERAL PUBLIC LICENSE Version 2.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
History</h1>
<p>v0.1 Initial release </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Feb 3 2022 21:07:00 for AccelStepperI2C by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
